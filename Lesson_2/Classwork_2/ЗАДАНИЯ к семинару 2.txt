ЗАДАНИЯ


Установите:
apt install cgroup-tools
	

Вспомните, как запустить изолированно bash:
sudo unshare --fork --pid --mount-proc bash
	

Создайте скрипт mem_generator.py, запустите его. Что произойдет? 


#!/bin/python3
list = ['']
i = 0
while True:
    list.append(i)
    i=i+1


Для того чтобы запускать скрипт делаем chmod +x mem_generator.py
и потом запуск ->  ./mem_generator.py


Создаем cgroup! 
cgcreate -a root -g memory:my_cgroup1


Теперь у нас есть лимиты, смотрим:


 /sys/fs/cgroup/my_cgroup1/ 
учтите, что cgroup - это такая специальная файловая система, и можно создать например просто директорию my_cgroup2 в
 /sys/fs/cgroup/ и там появятся все файлы для ограничения cgroup.
И её теперь также можно юзать как и при cgcreate, сделайте её тоже.


Давайте выставим ограничение памяти в 512М 


echo 512M > /sys/fs/cgroup/my_cgroup1/memory.max
обратите внимание на 
cat /sys/fs/cgroup/my_cgroup1/memory.max
что внутри? 


Далее - выполняем запуск программы баш с учетом лимитов с помощью:
cgexec -g memory:my_cgroup1 /bin/bash
	

Запустим там mem_generator.py а во втором окне перед запуском сделайте наблюдение с помощью watch -n 0.2 free -h 
Также можем запустить и сам mem_generator.py c помощью cgexec.
Главное понять что с помощью cgexec мы можем запускать любое приложение с ограниченными лимитами.
А что если запустить unshare?


cgexec -g memory:my_cgroup1 unshare -m -p -f --mount-proc  /bin/bash


        Получаем условный “контейнер”, где мы можем в баше запускать что угодно с ограниченными ресурсами.
        Запустите скрипт и смотрите одновременно на память с помощью watch


LXC
Собственно, таким образом и происходит взаимодействие с контрольными группами.
По факту же, сегодня практика больше будет касаться LXC-контейнеров. Почему они (?):
1. Они максимально похожи на системную обвязку. В частности - на контрольные группы
2. Они также имеют сходство с контейнерами. В частности - с Docker.
Задание:
Если у вас новая машина, то надо установить lxc и утилиты 


apt install lxc
apt install lxc-templates


перед первым использованием необходимо выполнить systemctl status lxc, если демон лежит - поднять .
Также показать выводы:


lxc storage list - смотрим список 
lxc network list
lxc remote list
lxc image list images: | more - список доступных имейджев с репозитория


cat /etc/default/lxc-net - настройки сети
cat /etc/lxc/default.conf 
ip a (напоследок обязательно)




	

Для начала необходимо повторить задание лекции: скачать темплейт, создать контейнер, сделать ему ограничение в 256 Мб ОЗУ.
Пример решения:
apt install lxc-templates
    lxc-create -n test123 -t ubuntu
    lxc-ls --fancy
lxc-stop -n test123
vi /var/lib/lxc/test123/config 
<<<--->>>
lxc.cgroup2.memory.max = 256M
lxc.start.auto  =  1
<<<--->>>
lxc-ls -f
free -m #внутри контейнера
	

	



Дополнительно можно узнать информацию о контейнере с помощью lxc-info -n test123


После задачи показать работу cgroups “на лету”:
lxc-cgroup -n test123 memory.max 256M
free -m
	



Задание:


Необходимо создать 2 контейнера и показать возможность взаимодействия между собой (командой пинг)


Пример решения:
lxc-create -n container1 -t ubuntu
lxc-create -n container2 -t ubuntu
<< ping from container1 to container2 >>
	

Итак, мы с вами вспомнили рассмотренный на лекциях материал. Далее работа будет построена следующим образом:
 я изначально покажу вам показательный пример изоляции пространства имен, который действительно можно использовать,
 а затем вы выполните ряд заданий “по образцу”.
Задание:
Добавить в каждый контейнер статический IP-адрес из той же подсети через config-file, показанный ранее на семинаре.
Пример решения:
Это примерный вариант решения, главное – чтобы логика была верной.
lxc.net.0.ipv4.address = 10.0.0.10/24
	

Задание:
Создать контейнер, проверить, что он создался и запустить команду без входа в контейнер, используя lxc-execute
Пример решения:
Это примерный вариант решения, главное – чтобы логика была верной.
lxc-execute /bin/ls
	Задание*:
Запустить контейнер, обязательно убедиться, что мы внутри контейнера!
Для этого проверить hostname, вывести список запущенных процессов.
Выполнить команду rm -rf /
Дождаться выполнения.
Остановить контейнер и просмотреть логи, которые предлагает lxc.
Пример решения:
Это примерный вариант решения, главное – чтобы логика была верной.
lxc-attach -n test123
rm -rf /
exit
lxc-stop -n test123
lxc-start -n test123
lxc-start -n test123 –logfile file.log